<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-1.18.0.css">
	
	</head>
	<body>

		<div id="qunit"></div>
		<div id="qunit-fixture"></div>
		<script src="http://code.jquery.com/qunit/qunit-1.18.0.js"></script>
		<script src="treeish.js"></script>
		<script>
		
			QUnit.test("dual ok", function( assert ) {
				var o="(",
					c=")",
					s={
						"" : ["", "", ""],
						"()" : ["", "", ""],
						"(a)" : ["", "a", ""],
						"a(b)c" : ["a", "b", "c"],
						"a(b)))" : ["a", "b", "))"],
						"(a))" : ["", "a", ")"],
						
					},
					k;
				for(k in s){
					assert.deepEqual(dual(k,o,c), s[k], "dual for " + k);
				}
			});
			QUnit.test("dual ko", function( assert ) {
				var o="(",
					c=")",
					s=[
						"(",
						")",
						"((a)",
						")(a)",
					],
					i=0,
					l=s.length;
				
				for(;i<l;i++){
					assert.throws( function(){
						dual(s[i],o,c);
					}, /malformed/i , "throwing for " + s[i]);
				}
			});
			QUnit.test("parsing ok string", function( assert ) {
				var o="(",
					c=")",
					s={
						"" : [],
						"a" : ["a"],
						"a(b)" : ["a", ["b"]],
						"a(b)c" : ["a", ["b"], "c"],
						"a((b))(c)" : ["a", [["b"]], [ "c"]],
					},
					k;
				for(k in s){
					assert.deepEqual(tree(k,o,c), s[k], "parsing for " + k);
				}
			});

			
			QUnit.test("rebuilding ok string", function( assert ) {
				var o="(",
					c=")",
					s={
						"" : [],
						"a" : ["a"],
						"a(b)" : ["a", ["b"]],
						"a(b)c" : ["a", ["b"], "c"],
						"a((b))(c)" : ["a", [["b"]], [ "c"]],
					},
					k;
				for(k in s){
					assert.strictEqual(tree_join(tree(k,o,c),o,c), k, "rebuilding for " + k);
				}
			});
			QUnit.test("translating ok string", function( assert ) {
				var o="(",
					c=")",
					o2="[",
					c2="]",
					s={
						"" : "",
						"a" : "a",
						"a(b)" : "a[b]",
						"a(b)c" : "a[b]c",
						"a((b))(c)" : "a[[b]][c]",
					},
					k;
				for(k in s){
					assert.strictEqual(tree_join(tree(k,o,c),o2,c2), s[k], "rebuilding for " + k);
				}
			});			
			QUnit.test("parsing ko string", function( assert ) {
				var o="(",
					c=")",
					s=[
						"(",
						")",
						"(()",
						")()",
						"())",
						"()("
					],
					i=0,
					l=s.length;
				
				for(;i<l;i++){
					assert.throws( function(){
						tree(s[i],o,c);
					}, /malformed/i , "throwing for " + s[i]);
				}
			});
		</script>
	</body>
</html>
